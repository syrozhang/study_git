#define  GPIO_KEY_G00A  (GPIO_TYPE_TG + 0)
#define  GPIO_KEY_G00B  (GPIO_TYPE_TG + 1)
#define  GPIO_KEY_G00C  (GPIO_TYPE_TG + 2)
#define  GPIO_KEY_G00D  (GPIO_TYPE_TG + 3)

#define  GPIO_KEY_G01A  (GPIO_TYPE_TG + 4)
#define  GPIO_KEY_G01B  (GPIO_TYPE_TG + 5)
#define  GPIO_KEY_G01C  (GPIO_TYPE_TG + 6)
#define  GPIO_KEY_G01D  (GPIO_TYPE_TG + 7)

#define  GPIO_KEY_G02A  (GPIO_TYPE_TG + 8)
#define  GPIO_KEY_G02B  (GPIO_TYPE_TG + 9)
#define  GPIO_KEY_G02C  (GPIO_TYPE_TG + 10)
#define  GPIO_KEY_G02D  (GPIO_TYPE_TG + 11)

#define  GPIO_KEY_G03A  (GPIO_TYPE_TG + 12)
#define  GPIO_KEY_G03B  (GPIO_TYPE_TG + 13)
#define  GPIO_KEY_G03C  (GPIO_TYPE_TG + 14)
#define  GPIO_KEY_G03D  (GPIO_TYPE_TG + 15)

#define  GPIO_KEY_G04A  (GPIO_TYPE_TG + 16)
#define  GPIO_KEY_G04B  (GPIO_TYPE_TG + 17)
#define  GPIO_KEY_G04C  (GPIO_TYPE_TG + 18)
#define  GPIO_KEY_G04D  (GPIO_TYPE_TG + 19)

#define  GPIO_KEY_G05A  (GPIO_TYPE_TG + 20)
#define  GPIO_KEY_G05B  (GPIO_TYPE_TG + 21)
#define  GPIO_KEY_G05C  (GPIO_TYPE_TG + 22)
#define  GPIO_KEY_G05D  (GPIO_TYPE_TG + 23)

#define  GPIO_KEY_G06A  (GPIO_TYPE_TG + 24)
#define  GPIO_KEY_G06B  (GPIO_TYPE_TG + 25)
#define  GPIO_KEY_G06C  (GPIO_TYPE_TG + 26)
#define  GPIO_KEY_G06D  (GPIO_TYPE_TG + 27)

#define  GPIO_KEY_G07A  (GPIO_TYPE_TG + 28)
#define  GPIO_KEY_G07B  (GPIO_TYPE_TG + 29)
#define  GPIO_KEY_G07C  (GPIO_TYPE_TG + 30)
#define  GPIO_KEY_G07D  (GPIO_TYPE_TG + 31)

#define  GPIO_KEY_G08A  (GPIO_TYPE_TG + 32)
#define  GPIO_KEY_G08B  (GPIO_TYPE_TG + 33)
#define  GPIO_KEY_G08C  (GPIO_TYPE_TG + 34)
#define  GPIO_KEY_G08D  (GPIO_TYPE_TG + 35)

#define  GPIO_KEY_G09A  (GPIO_TYPE_TG + 36)
#define  GPIO_KEY_G09B  (GPIO_TYPE_TG + 37)
#define  GPIO_KEY_G09C  (GPIO_TYPE_TG + 38)
#define  GPIO_KEY_G09D  (GPIO_TYPE_TG + 39)

#define  GPIO_KEY_G10A  (GPIO_TYPE_TG + 40)
#define  GPIO_KEY_G10B  (GPIO_TYPE_TG + 41)
#define  GPIO_KEY_G10C  (GPIO_TYPE_TG + 42)
#define  GPIO_KEY_G10D  (GPIO_TYPE_TG + 43)

#define  GPIO_KEY_G11A  (GPIO_TYPE_TG + 44)
#define  GPIO_KEY_G11B  (GPIO_TYPE_TG + 45)
#define  GPIO_KEY_G11C  (GPIO_TYPE_TG + 46)
#define  GPIO_KEY_G11D  (GPIO_TYPE_TG + 47)

#define  GPIO_KEY_G12A  (GPIO_TYPE_UT + 2)
#define  GPIO_KEY_G12B  (GPIO_TYPE_UT + 3)
#define  GPIO_KEY_G12C  (GPIO_TYPE_UT + 4)
#define  GPIO_KEY_G12D  (GPIO_TYPE_UT + 5)

#define  GPIO_KEY_G13A  (GPIO_TYPE_UT + 6)
#define  GPIO_KEY_G13B  (GPIO_TYPE_UT + 7)
#define  GPIO_KEY_G13C  (GPIO_TYPE_UT + 8)
#define  GPIO_KEY_G13D  (GPIO_TYPE_UT + 9)

#define  GPIO_KEY_G14A  (GPIO_TYPE_UT + 10)
#define  GPIO_KEY_G14B  (GPIO_TYPE_UT + 11)
#define  GPIO_KEY_G14C  (GPIO_TYPE_UT + 12)
#define  GPIO_KEY_G14D  (GPIO_TYPE_UT + 13)

#define  GPIO_KEY_G15A  (GPIO_TYPE_UT + 16)
#define  GPIO_KEY_G15B  (GPIO_TYPE_UT + 17)
#define  GPIO_KEY_G15C  (GPIO_TYPE_UT + 18)
#define  GPIO_KEY_G15D  (GPIO_TYPE_UT + 19)

#define  GPIO_KEY_G16A  (GPIO_TYPE_UT + 20)
#define  GPIO_KEY_G16B  (GPIO_TYPE_UT + 21)
#define  GPIO_KEY_G16C  (GPIO_TYPE_UT + 22)
#define  GPIO_KEY_G16D  (GPIO_TYPE_UT + 23)

#define  GPIO_KEY_G17A  (GPIO_TYPE_UT + 24)
#define  GPIO_KEY_G17B  (GPIO_TYPE_UT + 25)
#define  GPIO_KEY_G17C  (GPIO_TYPE_UT + 26)
#define  GPIO_KEY_G17D  (GPIO_TYPE_UT + 27)

#define  GPIO_KEY_G18A  (GPIO_TYPE_FM + 31)
#define  GPIO_KEY_G18B  (GPIO_TYPE_FM + 32)
#define  GPIO_KEY_G18C  (GPIO_TYPE_FM + 31)
#define  GPIO_KEY_G18D  (GPIO_TYPE_FM + 32)

#define  GPIO_KEY_G19A  (GPIO_TYPE_FM + 33)
#define  GPIO_KEY_G19B  (GPIO_TYPE_FM + 34)
#define  GPIO_KEY_G19C  (GPIO_TYPE_FM + 35)
#define  GPIO_KEY_G19D  (GPIO_TYPE_FM + 36)

#define  GPIO_KEY_G20A  (GPIO_TYPE_FM + 37)
#define  GPIO_KEY_G20B  (GPIO_TYPE_FM + 38)
#define  GPIO_KEY_G20C  (GPIO_TYPE_FM + 39)
#define  GPIO_KEY_G20D  (GPIO_TYPE_FM + 40)

UINT16  uisGpioKey[] = {  GPIO_KEY_G00A, GPIO_KEY_G00B, GPIO_KEY_G00C, GPIO_KEY_G00D,
	                      GPIO_KEY_G01A, GPIO_KEY_G01B, GPIO_KEY_G01C, GPIO_KEY_G01D,
	                      GPIO_KEY_G02A, GPIO_KEY_G02B, GPIO_KEY_G02C, GPIO_KEY_G02D,
	                      GPIO_KEY_G03A, GPIO_KEY_G03B, GPIO_KEY_G03C, GPIO_KEY_G03D,
	                      GPIO_KEY_G04A, GPIO_KEY_G04B, GPIO_KEY_G04C, GPIO_KEY_G04D,
	                      GPIO_KEY_G05A, GPIO_KEY_G05B, GPIO_KEY_G05C, GPIO_KEY_G05D,
	                      GPIO_KEY_G06A, GPIO_KEY_G06B, GPIO_KEY_G06C, GPIO_KEY_G06D,
	                      GPIO_KEY_G07A, GPIO_KEY_G07B, GPIO_KEY_G07C, GPIO_KEY_G07D,
	                      GPIO_KEY_G08A, GPIO_KEY_G08B, GPIO_KEY_G08C, GPIO_KEY_G08D,
	                      GPIO_KEY_G09A, GPIO_KEY_G09B, GPIO_KEY_G09C, GPIO_KEY_G09D,
	                      GPIO_KEY_G10A, GPIO_KEY_G10B, GPIO_KEY_G10C, GPIO_KEY_G10D,
	                      GPIO_KEY_G11A, GPIO_KEY_G11B, GPIO_KEY_G11C, GPIO_KEY_G11D,
	                      GPIO_KEY_G12A, GPIO_KEY_G12B, GPIO_KEY_G12C, GPIO_KEY_G12D,
	                      GPIO_KEY_G13A, GPIO_KEY_G13B, GPIO_KEY_G13C, GPIO_KEY_G13D,
	                      GPIO_KEY_G14A, GPIO_KEY_G14B, GPIO_KEY_G14C, GPIO_KEY_G14D,
	                      GPIO_KEY_G15A, GPIO_KEY_G15B, GPIO_KEY_G15C, GPIO_KEY_G15D,
	                      GPIO_KEY_G16A, GPIO_KEY_G16B, GPIO_KEY_G16C, GPIO_KEY_G16D,
	                      GPIO_KEY_G17A, GPIO_KEY_G17B, GPIO_KEY_G17C, GPIO_KEY_G17D,
	                      GPIO_KEY_G18A, GPIO_KEY_G18B, GPIO_KEY_G18C, GPIO_KEY_G18D,
	                      GPIO_KEY_G19A, GPIO_KEY_G19B, GPIO_KEY_G19C, GPIO_KEY_G19D,
	                      GPIO_KEY_G20A, GPIO_KEY_G20B, GPIO_KEY_G20C, GPIO_KEY_G20D
	                   };

#define  ADDR_KEY_SDATA_TG  (0xb0000000 + TG_GPIO_OV + 0)
#define  ADDR_KEY_REQ_TG    (0xb0000000 + TG_GPIO_OV + 0)
#define  ADDR_KEY_RDATA_TG  (0xb0000000 + TG_GPIO_IV + 0)
#define  ADDR_KEY_ACK_TG    (0xb0000000 + TG_GPIO_IV + 0)

#define  ADDR_KEY_SDATA_UT  (0xb0000000 + UT_GPIO_OV + 0)
#define  ADDR_KEY_REQ_UT    (0xb0000000 + UT_GPIO_OV + 0)
#define  ADDR_KEY_RDATA_UT  (0xb0000000 + UT_GPIO_IV + 0)
#define  ADDR_KEY_ACK_UT    (0xb0000000 + UT_GPIO_IV + 0)

extern  UINT8  GpioCountMax[];

#define  C_SEND_WAIT_TIME  250  // ?? 200

void  mySetGpio(UINT16 gpio, UINT8 val)
{
	UINT32  data;
	
	if((gpio&0xff)>=GpioCountMax[gpio>>8])
		return;
	if((gpio>>8)>=GPIO_TYPE_TOL)
		return;
	if((gpio&0xff)>=32)
		data = (UINT32)0x01<<((gpio&0xff)-32);
	else
		data = (UINT32)0x01<<(gpio&0xff);
	switch(gpio>>8)
	{
		case  ((GPIO_TYPE_FM)>>8):
			if((gpio&0xff)<32)
			{
				if(val>0)
					hwFmGpioLsbWrite(hwFmGpioLsbRead()|data);
				else
					hwFmGpioLsbWrite(hwFmGpioLsbRead()&(data^0xffffffff));
			}
			else
			{
				if(val>0)
					hwFmGpioMsbWrite(hwFmGpioMsbRead()|data);
				else
					hwFmGpioMsbWrite(hwFmGpioMsbRead()&(data^0xffffffff));
			}
			break;
		case  ((GPIO_TYPE_UT)>>8):
			if(val>0)
				hwUsbGpioWrite(hwUsbGpioRead()|data);
			else
				hwUsbGpioWrite(hwUsbGpioRead()&(data^0xffffffff));
			break;
		case  ((GPIO_TYPE_TG)>>8):
			if((gpio&0xff)<32)
			{
				if(val>0)
					hwTgGpioLsbWrite(hwTgGpioLsbRead()|data);
				else
					hwTgGpioLsbWrite(hwTgGpioLsbRead()&(data^0xffffffff));
			}
			else
			{
				if(val>0)
					hwTgGpioMsbWrite(hwTgGpioMsbRead()|data);
				else
					hwTgGpioMsbWrite(hwTgGpioMsbRead()&(data^0xffffffff));
			}
			break;
		default:
			break;
	}
}

UINT8  myGetGpio(UINT16 gpio)
{
	UINT32  data;
	
	if((gpio&0xff)>=GpioCountMax[gpio>>8])
		return  0;
	if((gpio>>8)>=GPIO_TYPE_TOL)
		return  0;
	if((gpio&0xff)>=32)
		data = (UINT32)0x01<<((gpio&0xff)-32);
	else
		data = (UINT32)0x01<<(gpio&0xff);
	switch(gpio>>8)
	{
		case  ((GPIO_TYPE_FM)>>8):
			if((gpio&0xff)<32)
				return  (hwFmGpioLsbRead()&data)?1:0;
			else
				return  (hwFmGpioMsbRead()&data)?1:0;
			break;
		case  ((GPIO_TYPE_UT)>>8):
			return  (hwUsbGpioRead()&data)?1:0;
			break;
		case  ((GPIO_TYPE_TG)>>8):
			if((gpio&0xff)<32)
				return  (hwTgGpioLsbRead()&data)?1:0;
			else
				return  (hwTgGpioMsbRead()&data)?1:0;
			break;
		default:
			break;
	}
}

void  gpioSetReq(UINT8 chnl, UINT8 val)
{
	UINT32  status;
	UINT32  gpiokey;
	
	gpiokey = 0x01<<(uisGpioKey[chnl*4+2]&0xff);
	
	ENTER_CRITICAL(status);
	if(chnl<12)
	{
		if(val>0)
			WRITE32(ADDR_KEY_REQ_TG, READ32(ADDR_KEY_REQ_TG)|gpiokey);
		else
			WRITE32(ADDR_KEY_REQ_TG, READ32(ADDR_KEY_REQ_TG)&(gpiokey^0xffffffff));
	}
	else
	{
		if(val>0)
			WRITE32(ADDR_KEY_REQ_UT, READ32(ADDR_KEY_REQ_UT)|gpiokey);
		else
			WRITE32(ADDR_KEY_REQ_UT, READ32(ADDR_KEY_REQ_UT)&(gpiokey^0xffffffff));
	}
	EXIT_CRITICAL(status);
}

void  gpioSetSdata(UINT8 chnl, UINT8 val)
{
	UINT32  status;
	UINT32  gpiokey;
	
	gpiokey = 0x01<<(uisGpioKey[chnl*4+3]&0xff);
	
	ENTER_CRITICAL(status);
	if(chnl<12)
	{
		if(val>0)
			WRITE32(ADDR_KEY_SDATA_TG, READ32(ADDR_KEY_SDATA_TG)|gpiokey);
		else
			WRITE32(ADDR_KEY_SDATA_TG, READ32(ADDR_KEY_SDATA_TG)&(gpiokey^0xffffffff));
	}
	else
	{
		if(val>0)
			WRITE32(ADDR_KEY_SDATA_UT, READ32(ADDR_KEY_SDATA_UT)|gpiokey);
		else
			WRITE32(ADDR_KEY_SDATA_UT, read32(ADDR_KEY_SDATA_UT)&(gpiokey^0xffffffff));
	}
	EXIT_CRITICAL(status);
}

void  handSendByte(UINT8 chnl, UINT8 value)
{
	UINT8  i,j;
	UINT8  flag1,flag2,count;
	UINT8  value16;
	
	value16 = ((value&0x0f)<<1)|0x40;
	value16 ^= 0xff;
	
	flag1 = MY_HIGH;
	count = 0;
	for(i=0;i<8;i++)
	{
		if(i==7)
		{
			if(count&0x01)
			{
				gpioSetSdata(chnl, 1);
				flag2 = 1;
			}
			else
			{
				gpioSetSdata(chnl, 0);
				flag2 = 0;
			}
		}
		else
		{
			if(value16&0x80)
			{
				gpioSetSdata(chnl, 1);
				flag2 = 1;
				count++;
			}
			else
			{
				gpioSetSdata(chnl, 0);
				flag2 = 0;
			}
		}
		
		if(flag1!=flag2)
		{
			flag1 = flag2;
			if(flag2==0)
				for(j=0;j<C_SEND_WAIT_TIME;j++);
		}
		
		gpioSetReq(chnl, MY_LOW);
		for(j=0;j<100;j++);
		gpioSetReq(chnl, MY_HIGH);
		
		value16 = value16<<1;
		for(j=0;j<C_SEND_WAIT_TIME;j++);
	}
	gpioSetSdata(chnl, MY_HIGH);
	for(j=0;j<100;j++);
}

UINT16  handReceiveByte(UINT8 chnl)
{
	UINT8  i,flag,ack;
	UINT8  value;
	
	UINT16  j;
	UINT16  count;
	
	UINT32  gpiokey0;
	UINT32  gpiokey1;
	
	gpiokey0 = 0x01<<(uisGpioKey[chnl*4+0]&0xff);
	gpiokey1 = 0x01<<(uisGpioKey[chnl*4+1]&0xff);
	
	gpioSetSdata(chnl, MY_HIGH);
	flag = MY_HIGH;
	ack = 1;
	value = 0;
	for(i=0;i<8;i++)
	{
		flag ^= 1;
		value = value<<1;
		
		count = 2000;
		if(ack)
		{
			ack = 0;
			while(--count)
			{
				if(chnl<12)
				{
					if((READ32(ADDR_KEY_RDATA_TG)&gpiokey1)==0)
						break;
				}
				else
				{
					if((READ32(ADDR_KEY_RDATA_UT)&gpiokey1)==0)
						break;
				}
			}
		}
		else
		{
			ack = 1;
			while(--count)
			{
				if(chnl<12)
				{
					if((READ32(ADDR_KEY_RDATA_TG)&gpiokey1))
						break;
				}
				else
				{
					if((READ32(ADDR_KEY_RDATA_UT)&gpiokey1))
						break;
				}
			}
		}
		if(count==0)
		{
			gpioSetReq(chnl, MY_HIGH);
			#if  C_4458_DEBUG
			    printf("hand receive byte error  ");
			#endif
			return  0xffff;
		}
		
		for(j=0;j<1750;j++);
		if(chnl<12)
		{
			if((READ32(ADDR_KEY_RDATA_TG)&gpiokey0))
				value++;
		}
		else
		{
			if((READ32(ADDR_KEY_RDATA_UT)&gpiokey0))
				value++;
		}
		
		gpioSetReq(chnl, flag);
	}
	
	for(j=0;j<1750;j++);  //?? 100
	return  value^0xff;
}

void  delay100us()
{
	UINT16  i;
	for(i=0;i<400;i++);
}

SINT32  readSlaveAD1271(UINT8 chnl)
{
	UINT8  ucErrCount;
	
	UINT16  ui16AdTemp;
	UINT16  ui16AdTemp1;
	UINT16  ui16AdTemp2;
	UINT16  ui16AdTemp3;
	
	UINT32  ul32AdDataL;
	UINT32  ul32AdDataH;
	
	UINT32  ul32AdData1;
	UINT32  ul32AdData2;
	UINT32  ul32AdData3;
	UINT32  ul32AdData4;
	UINT32  ul32Sign;
	
	ucErrCount = 0;
	while(ucErrCount++<3)
	{
		handSendByte(chnl, 0x07);
		
		ui16AdTemp = handReceiveByte(chnl);
		if(ui16AdTemp==0xffff)
		{
			delay100us();
			continue;
		}
		ul32AdDataL = (UINT32)ui16AdTemp<<16;
		ui16AdTemp1 = ui16AdTemp;
		
		ui16AdTemp = handReceiveByte(chnl);
		if(ui16AdTemp==0xffff)
		{
			delay100us();
			continue;
		}
		ul32AdDataL |= (UINT32)ui16AdTemp<<8;
		ui16AdTemp2 = ui16AdTemp;
		
		ui16AdTemp = handReceiveByte(chnl);
		if(ui16AdTemp==0xffff)
		{
			delay100us();
			continue;
		}
		ul32AdDataL |= (UINT32)ui16AdTemp;
		ui16AdTemp3 = ui16AdTemp;
		
		ul32AdDataH = ul32AdDataL;
		ul32Sign = 0;
		#if  C_4458_DEBUG
		    #if  D_ADJUST_CURR
		        printf("Hx=%02x %02x %02x  ",ui16AdTemp1,ui16AdTemp2,ui16AdTemp3);
		    #endif
		#endif
		if(ul32AdDataL&0x800000)
		{
			ul32AdDataL = (ul32AdDataL^0xffffff)+1;
			ul32Sign = 0x800000;
		}
		
		ul32AdData4 = 0;
		ul32AdData3 = 0;
		ul32AdData2 = ul32AdDataL>>16;
		ul32AdData1 = ul32AdDataL&0xffff;
		
		ul32AdData2 *= 66000;
		ul32AdData1 *= 66000;
		ul32AdData2 += (ul32AdData1>>16);
		ul32AdData1 = (ul32AdData1&0xffff);
		ul32AdData3 = ul32AdData2>>16;
		ul32AdData2 = (ul32AdData2&0xffff);
		
		ul32AdData3 *= 10000;
		ul32AdData2 *= 10000;
		ul32AdData1 *= 10000;
		ul32AdData2 += (ul32AdData1>>16);
		ul32AdData1 = (ul32AdData1&0xffff);
		ul32AdData3 += (ul32AdData2>>16);
		ul32AdData2 = (ul32AdData2&0xffff);
		
		ul32AdDataL = (ul32AdData3<<8)|(ul32AdData2>>8);
		
		#if  D_ADJUST_CURR
		    ul32AdDataL = ul32AdDataL/100;
		#else
		    ul32AdDataL = ul32AdDataL/1000;
		#endif
		if(ul32Sign)
			ul32AdDataL = (ul32AdDataL^0xffffffff)+1;
		return  ul32AdDataL;
	}
	#if  C_4458_DEBUG
	    printf("channel%d read1271  ",chnl+1);
	#endif
	return  0xffff;
}

SINT16  readSlaveAD458(UINT8 chnl)
{
	UINT8  ucErrCount;
	
	UINT16  ui16AdTemp;
	UINT16  ui16AdData;
	
	ucErrCount = 0;
	while(ucErrCount++<3)
	{
		handSendByte(chnl, 0x04);
		
		ui16AdTemp = handReceiveByte(chnl);
		if(ui16AdTemp==0xffff)
		{
			delay100us();
			continue;
		}
		ui16AdData = ui16AdTemp<<8;
		
		ui16AdTemp = handReceiveByte(chnl);
		if(ui16AdTemp==0xffff)
		{
			delay100us();
			continue;
		}
		ui16AdData |= ui16AdTemp;
		return  ui16AdData;
	}
	#if  C_4458_DEBUG
	    printf("channel%d read458  ",chnl+1);
	#endif
	return  -1;
}

UINT16  getSlaveTime(UINT8 chnl)
{
	UINT8  ucErrCount;
	
	UINT16  ui16AdTemp;
	UINT16  ui16AdTime;
	
	ucErrCount = 0;
	while(ucErrCount++<3)
	{
		handSendByte(chnl, 0x06);
		
		ui16AdTemp = handReceiveByte(chnl);
		if(ui16AdTemp==0xffff)
		{
			delay100us();
			continue;
		}
		ui16AdTime = ui16AdTemp<<8;
		
		ui16AdTemp = handReceiveByte(chnl);
		if(ui16AdTemp==0xffff)
		{
			delay100us();
			continue;
		}
		ui16AdTime |= ui16AdTemp;
		return  ui16AdTime;
	}
	#if  C_4458_DEBUG
	    printf("channel%d slave time  ",chnl+1);
	#endif
	return  0;
}

void  setSlaveLayer(UINT8 chnl, UINT8 value)
{
	UINT8  ucErrCount;
	
	UINT16  ui16AdTemp;
	
	ucErrCount = 0;
	while(ucErrCount++<3)
	{
		handSendByte(chnl, value|0x08);
		
		ui16AdTemp = handReceiveByte(chnl);
		if(ui16AdTemp==0xffff)
		{
			delay100us();
			continue;
		}
		return;
	}
	#if  C_4458_DEBUG
	    printf("channel%d slave layer  ",chnl+1);
	#endif
}